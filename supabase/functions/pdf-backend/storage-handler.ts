/**
 * Storage handler for PDFs generated by the pdf-backend function
 * Handles uploading PDFs to Supabase storage and updating document records
 */
import { DocumentType, documentTypeConfig } from './types.ts';
import { PDFErrorType, createPDFError } from './utils.ts';

/**
 * Interface for PDF storage result
 * @interface StorageResult
 */
interface StorageResult {
  /** Storage path/key for the PDF */
  storageKey: string;
  /** Public URL for the stored PDF */
  url: string;
}

/**
 * Stores a PDF in Supabase Storage and returns the URL
 * 
 * @param {any} supabaseClient - Supabase client with admin privileges
 * @param {DocumentType} documentType - Type of document (invoice, estimate, etc.)
 * @param {any} documentData - Document data
 * @param {Uint8Array} pdfBytes - PDF file content as bytes
 * @param {boolean} [overwriteExisting=false] - Whether to explicitly overwrite any existing PDF
 * @returns {Promise<StorageResult>} Object with storage key and public URL
 * @throws {Error} If storage fails
 */
export async function storePDF(
  supabaseClient: any,
  documentType: DocumentType,
  documentData: any,
  pdfBytes: Uint8Array,
  overwriteExisting: boolean = false
): Promise<StorageResult> {
  try {
    const config = documentTypeConfig[documentType];
    if (!config) {
      throw createPDFError(
        PDFErrorType.VALIDATION_ERROR,
        `Invalid document type: ${documentType}`
      );
    }

    // Create a storage key based on document type and UID or ID
    const documentUid = documentData[config.uidField] || documentData.id;
    const storageFolder = config.storageFolder;
    const storageKey = `${storageFolder}/${documentUid}.pdf`;

    console.log(`Storing PDF at ${storageKey} and overwriting any existing file`);
    
    // If overwriteExisting is true, check for and explicitly delete any existing file before upload
    if (overwriteExisting) {
      try {
        console.log(`Checking for existing file at ${storageKey} to explicitly delete it`);
        // First check if the file exists
        const { data: listData } = await supabaseClient
          .storage
          .from('pdfs')
          .list(storageFolder);
          
        const existingFile = listData?.find(file => file.name === `${documentUid}.pdf`);
        
        if (existingFile) {
          console.log(`Found existing PDF at ${storageKey}, explicitly deleting before upload`);
          // Explicitly delete the file to ensure clean replacement
          const { error: deleteError } = await supabaseClient
            .storage
            .from('pdfs')
            .remove([storageKey]);
            
          if (deleteError) {
            console.warn(`Error deleting existing file: ${deleteError.message}`);
            // Continue anyway as upsert should still work
          } else {
            console.log(`Successfully deleted existing file at ${storageKey}`);
          }
        } else {
          console.log(`No existing file found at ${storageKey}`);
        }
      } catch (error) {
        // Log but continue - this error shouldn't prevent the upload
        console.warn(`Error checking/deleting existing file: ${error.message}`);
      }
    } else {
      // Just check if file exists but don't explicitly delete
      try {
        const { data: existingFile } = await supabaseClient
          .storage
          .from('pdfs')
          .getPublicUrl(storageKey);
        
        if (existingFile && existingFile.publicUrl) {
          console.log(`Found existing PDF at ${storageKey}, will overwrite via upsert`);
        }
      } catch (error) {
        // Ignore errors here - just means file doesn't exist
        console.log(`No existing file found at ${storageKey}`);
      }
    }

    // Upload PDF to Supabase Storage with upsert to overwrite any existing file
    const { data: uploadData, error: uploadError } = await supabaseClient
      .storage
      .from('pdfs')
      .upload(storageKey, pdfBytes, {
        contentType: 'application/pdf',
        upsert: true,  // Ensure we overwrite any existing file
        cacheControl: 'no-cache'  // Prevent caching to ensure the latest version is always served
      });

    if (uploadError) {
      throw createPDFError(
        PDFErrorType.STORAGE_ERROR,
        `Failed to upload PDF to storage: ${uploadError.message}`,
        uploadError
      );
    }

    // Get the public URL for the uploaded PDF with cache-busting parameter
    // Add a timestamp query parameter to prevent browser caching
    const timestamp = Date.now();
    const { data: urlData } = await supabaseClient
      .storage
      .from('pdfs')
      .getPublicUrl(`${storageKey}?t=${timestamp}`);

    if (!urlData || !urlData.publicUrl) {
      throw createPDFError(
        PDFErrorType.STORAGE_ERROR,
        'Failed to get public URL for uploaded PDF'
      );
    }

    return {
      storageKey,
      url: urlData.publicUrl
    };
  } catch (error) {
    console.error('Error storing PDF:', error);
    
    // Re-throw with proper error structure if not already
    if (error.type && Object.values(PDFErrorType).includes(error.type)) {
      throw error;
    }
    
    throw createPDFError(
      PDFErrorType.STORAGE_ERROR,
      `Failed to store PDF: ${error.message || 'Unknown error'}`,
      error
    );
  }
}

/**
 * Updates a document record with the PDF URL
 * 
 * @param {any} supabaseClient - Supabase client with admin privileges
 * @param {DocumentType} documentType - Type of document (invoice, estimate, etc.)
 * @param {string} documentId - ID of the document to update
 * @param {string} pdfUrl - URL of the stored PDF
 * @returns {Promise<void>}
 * @throws {Error} If update fails
 */
export async function updateDocumentWithPdfUrl(
  supabaseClient: any,
  documentType: DocumentType,
  documentId: string,
  pdfUrl: string
): Promise<void> {
  try {
    const config = documentTypeConfig[documentType];
    if (!config) {
      throw createPDFError(
        PDFErrorType.VALIDATION_ERROR,
        `Invalid document type: ${documentType}`
      );
    }

    console.log(`Updating ${documentType} ${documentId} with PDF URL: ${pdfUrl}`);

    // Ensure the URL has a cache-busting parameter
    const timestamp = Date.now();
    const urlWithCacheBusting = pdfUrl.includes('?') 
      ? `${pdfUrl}&t=${timestamp}` 
      : `${pdfUrl}?t=${timestamp}`;
    
    console.log(`Updating document record with cache-busted URL: ${urlWithCacheBusting}`);
    
    // Update the document with the PDF URL and timestamp
    const { error } = await supabaseClient
      .from(config.tableName)
      .update({
        supabase_pdf_url: urlWithCacheBusting,
        pdf_url_updated_at: new Date().toISOString()
      })
      .eq('id', documentId);

    if (error) {
      throw createPDFError(
        PDFErrorType.FETCH_ERROR,
        `Failed to update document with PDF URL: ${error.message}`,
        error
      );
    }
  } catch (error) {
    console.error(`Error updating ${documentType} ${documentId} with PDF URL:`, error);
    
    // Re-throw with proper error structure if not already
    if (error.type && Object.values(PDFErrorType).includes(error.type)) {
      throw error;
    }
    
    throw createPDFError(
      PDFErrorType.FETCH_ERROR,
      `Failed to update document with PDF URL: ${error.message || 'Unknown error'}`,
      error
    );
  }
}
